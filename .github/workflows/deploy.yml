name: ğŸš€ Backend Build â†’ ECR â†’ Terraform â†’ Smoke-test

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    # Optional: protect your production environment with GitHub Environments
    environment: production
    concurrency:
      group: deploy-backend-${{ github.ref }}
      cancel-in-progress: true

    steps:
      # 1) Checkout your code
      - name: â¬‡ï¸ Checkout code
        uses: actions/checkout@v3

      # 2) Configure AWS credentials for ECR, ECS, RDS, VPC, etc.
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            us-east-1     # â† change if needed

      # 3) Login to ECR so we can push images
      - name: ğŸ³ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4) Build & push your Docker image
      - name: ğŸ› ï¸ Build & Push Docker Image
        working-directory: backend
        env:
          ECR_REGISTRY:   ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: deploymate-backend     # â† your repo name
          IMAGE_TAG:      ${{ github.sha }}      # use the commit SHA as tag
        run: |
          docker build \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      # 5) Install Terraform without the Node.js shim
      - name: ğŸ“¦ Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.5
          terraform_wrapper: false

      # 6) Generate terraform.tfvars dynamically from GitHub Secrets
      #    (so you donâ€™t check sensitive tfvars into Git)
      - name: ğŸ“ Create Terraform vars file
        working-directory: infra
        run: |
          cat > terraform.tfvars <<EOF
          private_subnet_ids = ${TERRAFORM_PRIVATE_SUBNET_IDS}
          public_subnet_ids  = ${TERRAFORM_PUBLIC_SUBNET_IDS}
          # any other variables you need, e.g.:
          # vpc_id            = "${TERRAFORM_VPC_ID}"
          EOF
        env:
          TERRAFORM_PRIVATE_SUBNET_IDS: ${{ secrets.PRIVATE_SUBNET_IDS }}
          TERRAFORM_PUBLIC_SUBNET_IDS:  ${{ secrets.PUBLIC_SUBNET_IDS }}
          # add more mappings here for other secrets

      # 7) Terraform init against your infra
      - name: ğŸ“œ Terraform Init
        working-directory: infra
        run: terraform init

      # 8) Terraform apply your changes (idempotentâ€”wonâ€™t recreate existing resources)
      - name: ğŸš§ Terraform Apply
        working-directory: infra
        run: terraform apply -auto-approve -input=false

      # 9) Smoke-test the ALB health endpoint
      - name: ğŸ©º Smoke-test ALB /healthz
        working-directory: infra
        run: |
          ALB_URL=$(terraform output -raw alb_dns_name)
          echo "â© Hitting http://$ALB_URL/healthz"
          curl --fail --silent --show-error "http://$ALB_URL/healthz"
